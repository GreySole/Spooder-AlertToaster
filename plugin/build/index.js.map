{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":[".././js/PluginBase.js",".././js/index.js","../webpack/bootstrap","../webpack/runtime/compat","../webpack/before-startup","../webpack/startup","../webpack/after-startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass PluginBase {\n}\nexports.default = PluginBase;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PluginBase_1 = __importDefault(require(\"./PluginBase\"));\n/*\nTypescript Sample Plugin\nUse onLoad as your starting point.\n*/\nclass AlertToaster extends PluginBase_1.default {\n    constructor() {\n        super(...arguments);\n        this.isAlertBox = true;\n        this.isConnected = false;\n        this.connectAlerts = {};\n        this.ttsVoices = ['david', 'helena', 'hedda', 'zira', 'hazel', 'haruka', 'hortense', 'lucia'];\n    }\n    onLoad() { }\n    onChat(message) { }\n    onCommunityChat(type, message) { }\n    onOSC(message) {\n        const activePlugins = this.activePlugins;\n        if (!this.isConnected && message.address.endsWith('/connect')) {\n            let pluginInfo = typeof message.args[0] === 'string' ? JSON.parse(message.args[0]) : {};\n            if (pluginInfo == 1) {\n                pluginInfo = {\n                    name: message.address.split('/')[1],\n                };\n            }\n            if ((pluginInfo.external == true && this.settings?.displayexternalconnects == true) ||\n                pluginInfo.external == false) {\n                let pluginName = activePlugins[pluginInfo.name]?.name != null\n                    ? activePlugins[pluginInfo.name].name\n                    : pluginInfo.name;\n                let externalTxt = pluginInfo.external == true ? ' externally' : '';\n                this.osc.sendToTCP('/alerttoaster/alert', JSON.stringify({\n                    icon: 'http://' +\n                        this.spooderConfig.host +\n                        ':' +\n                        this.spooderConfig.hostPort +\n                        '/icons/' +\n                        pluginInfo.name +\n                        '.png',\n                    text: pluginName + ': OSC Connected' + externalTxt,\n                }));\n            }\n        }\n        if (message.address != '/alerttoaster/connect' && message.address.endsWith('/connect')) {\n            let pluginInfo = typeof message.args[0] === 'string' ? JSON.parse(message.args[0]) : {};\n            if (pluginInfo == 1) {\n                pluginInfo = {\n                    name: message.address.split('/')[1],\n                };\n            }\n            let pluginName = activePlugins[pluginInfo.name]?.name != null\n                ? activePlugins[pluginInfo.name].name\n                : pluginInfo.name;\n            if ((pluginInfo.external == true && this.settings?.displayexternalconnects == true) ||\n                pluginInfo.external == false) {\n                let externalTxt = pluginInfo.external == true ? ' externally' : '';\n                this.connectAlerts[pluginInfo.name] = {\n                    address: '/spooder/alert',\n                    data: JSON.stringify({\n                        icon: 'http://' +\n                            this.spooderConfig.host +\n                            ':' +\n                            this.spooderConfig.hostPort +\n                            '/icons/' +\n                            pluginInfo.name +\n                            '.png',\n                        text: pluginName + ': OSC Connected' + externalTxt,\n                    }),\n                };\n            }\n            return;\n        }\n        if (message.address == '/alerttoaster/connect') {\n            this.isConnected = true;\n            this.osc.sendToTCP('/alerttoaster/plugins', JSON.stringify(this.connectAlerts));\n        }\n        if (message.address.startsWith('/spooder/alert')) {\n            this.osc.sendToTCP('/alerttoaster/alert', message.args[0]);\n        }\n    }\n    async onEvent(eventName, eventData) {\n        if (eventName == 'eventstart') {\n            this.osc.sendToTCP('/events/start/' + eventName, eventData.username + ' has activated ' + eventName + '!');\n        }\n        else if (eventName == 'play_tts') {\n            const ttsData = eventData.pluginEventData;\n            if (!ttsData) {\n                console.error('No TTS data provided');\n                return;\n            }\n            console.log('AlertToaster TTS Data', ttsData);\n            let fullMessage = eventData.message;\n            let firstWord = fullMessage.substring(0, fullMessage.indexOf(' ')).toLowerCase();\n            let voice = 'david';\n            let sound = '';\n            if (ttsData.voice === 'tts') {\n                if (this.ttsVoices.includes(firstWord)) {\n                    voice = firstWord.trim();\n                    fullMessage = fullMessage.substring(firstWord.length + 1);\n                }\n            }\n            else {\n                voice = ttsData.voice || 'david';\n            }\n            if (ttsData.sound_type === 'single') {\n                sound = ttsData.sound || '';\n            }\n            else {\n                const soundKey = Object.keys(ttsData).find((key) => key.includes(voice));\n                if (soundKey) {\n                    sound = ttsData[soundKey] || '';\n                }\n            }\n            let profilePicture = '';\n            if (ttsData.icon_type === 'profile_pic') {\n                profilePicture = await this.getProfilePicture(eventData.username);\n            }\n            else {\n                profilePicture = ttsData.icon || '';\n            }\n            this.osc.sendToTCP('/alerttoaster/tts', JSON.stringify({\n                icon: 'tts',\n                text: fullMessage,\n                voice: voice,\n                sound: sound,\n                ttsIcon: profilePicture,\n            }));\n        }\n        else if (eventName == 'show_alert') {\n            let alertText = eventData.pluginEventData?.alerttext ?? '';\n            this.osc.sendToTCP('/alerttoaster/alert', {\n                icon: eventData.pluginEventData?.icon,\n                text: alertText,\n                sound: eventData.pluginEventData?.sound,\n                boxColor: eventData.pluginEventData?.boxColor,\n                borderColor: eventData.pluginEventData?.borderColor,\n            });\n        }\n    }\n    getProfilePicture(user) {\n        if (!this.modules.stream.twitch) {\n            return;\n        }\n        return this.modules.stream.twitch.getUserInfo(user).then((data) => {\n            return data['profile_image_url'];\n        });\n    }\n}\nexports.default = AlertToaster;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(588);\n",""],"names":[],"sourceRoot":""}